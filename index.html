<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Word Serial Lab</title>

  <!-- === libs (CDN) === -->
  <script src="https://cdn.jsdelivr.net/npm/wanakana@5.0.2/dist/wanakana.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/kuroshiro@1.2.0/dist/kuroshiro.min.js"></script>
  <script
    src="https://cdn.jsdelivr.net/npm/kuroshiro-analyzer-kuromoji@1.1.0/dist/kuroshiro-analyzer-kuromoji.min.js"></script>

  <link rel="stylesheet" href="style.css">
</head>

<body>
  <div class="app">
    <header>
      <div>
        <h1>Word Serial Lab</h1>
        <div class="subtitle">Bag → Operation → New Bag | JSON ロード / 正規化 / 集合演算 / 編集</div>
      </div>
    </header>

    <div class="layout">
      <aside class="sidebar card">
        <nav class="tabs">
          <button class="btn tab-button active" data-tab="import">Import</button>
          <button class="btn tab-button" data-tab="operations">Operations</button>
          <button class="btn tab-button" data-tab="export">Export</button>
        </nav>

        <section class="tab-panel active" data-panel="import">
          <h3>0) 入力データ</h3>
          <!-- general description removed -->
          <div class="panel-grid">
            <div>
              <div class="muted small" style="margin-bottom:4px;">1) サーバー上のプリセットから選択</div>
              <div class="inline">
                <span class="muted small" style="padding: 0 8px;">デフォルトバッグ:</span>
                <select id="selFile" class="input" style="min-width:220px"></select>
                <button id="btnLoad" class="btn primary">選択 JSON を Bag 化</button>
              </div>
            </div>
            <div>
              <div class="muted small" style="margin-bottom:4px;">2) ローカルの JSON ファイルを読み込み</div>
              <div class="inline" style="display: flex; align-items: center; gap: 10px;">
                <input type="file" id="filePick" accept=".json" style="display: none" />
                <button id="btnFileSelect" class="btn">ローカル JSON を選択</button>
              </div>
              <div class="muted small" style="margin-top:4px;">JSON 形式： <span
                  class="mono">[{"id":"…","lemmas":["語1","語2"],"glosses":[…]}]</span>（lemmas を単語として取り込み）</div>
            </div>
            <div>
              <div class="muted small" style="margin-bottom:4px;">3) テキスト貼り付けから作成</div>
              <input id="bagNameInput" class="input" placeholder="Bag 名（省略可）" />
              <div style="display: flex; flex-direction: column; gap: 8px;">
                <textarea id="pasteArea" rows="8" class="mono" placeholder="一行に一語（任意）"></textarea>
                <button id="btnMakeBagFromText" class="btn">貼り付けテキストからBag化</button>
              </div>
            </div>
            <div id="importLog" class="muted mono small"></div>
          </div>
        </section>

        <section class="tab-panel" data-panel="operations">
          <h3>1) 操作</h3>
          <div class="panel-grid">
            <div class="op-group">
              <h4>かな正規化</h4>
              <p class="muted small" style="margin: 4px 0 8px;">ひらがな・カタカナの正規化や相互変換を行います。</p>
              <select id="selSrcNorm" class="input" title="入力とするBagを選択"></select>
              <div class="inline">
                <button id="btnNorm" class="btn ok"
                  title="選択したBagの単語をすべてひらがなに変換します (Kuroshiro / WanaKana使用)">ひらがな化</button>
                <button id="btnKatakana" class="btn" title="選択したBagの単語をすべてカタカナに変換します">カタカナ化</button>
              </div>
            </div>

            <div class="op-group">
              <h4>文字変換</h4>
              <p class="muted small" style="margin: 4px 0 8px;">ローマ字変換やケース変換、反転などを行います。</p>
              <select id="selSrcTransform" class="input" title="入力とするBagを選択"></select>
              <div class="inline">
                <button id="btnRomaji" class="btn" title="ひらがな・カタカナをローマ字に変換します">ローマ字化</button>
                <button id="btnUpper" class="btn" title="アルファベットを大文字に変換します">大文字化</button>
                <button id="btnLower" class="btn" title="アルファベットを小文字に変換します">小文字化</button>
                <button id="btnReverse" class="btn" title="文字列を逆順にします (例: あいう→ういあ)">反転</button>
              </div>
            </div>

            <div class="op-group">
              <h4>文字付与 (Appender)</h4>
              <p class="muted small" style="margin: 4px 0 8px;">全ての単語の先頭や末尾に、指定した文字列を付与します。</p>
              <select id="selSrcAppend" class="input" title="入力とするBagを選択"></select>
              <div class="inline">
                <input id="appendPrefix" class="input" placeholder="prefix" title="先頭につける文字列" />
                <input id="appendSuffix" class="input" placeholder="suffix" title="末尾につける文字列" />
                <button id="btnAppend" class="btn" title="付与を実行します">付与</button>
              </div>
            </div>

            <div class="op-group">
              <h4>アナグラム</h4>
              <p class="muted small" style="margin: 4px 0 8px;">単語内の文字の並び順をランダムに入れ替えます。</p>
              <select id="selSrcAnagram" class="input" title="入力とするBagを選択"></select>
              <div class="inline">
                <button id="btnAnagram" class="btn" title="文字をシャッフルします">シャッフル</button>
              </div>
            </div>

            <div class="op-group">
              <h4>文字削除</h4>
              <p class="muted small" style="margin: 4px 0 8px;">指定した文字を単語から削除します。</p>
              <select id="selSrcDel" class="input" title="入力とするBagを選択"></select>
              <div class="inline">
                <input id="delChars" class="input" placeholder="削除する文字（例：ん）" title="削除したい文字を入力してください" />
                <label class="muted small" title="入力欄の文字をひらがな化してから処理に使用します"><input type="checkbox" id="ckNormDel"
                    checked /> 入力をひらがな化</label>
                <label class="muted small" title="処理前に入力Bagの内容をひらがな化します"><input type="checkbox" id="ckPreNormDel"> Bag
                  をひらがな化</label>
                <button id="btnDel" class="btn warn" title="指定した文字を各単語から削除します">delete chars</button>
              </div>
            </div>

            <div class="op-group">
              <h4>集合演算</h4>
              <p class="muted small" style="margin: 4px 0 8px;">2つのBag間で和・差・積・対称差の集合演算を行います。</p>
              <div class="inline">
                <select id="selSrcUnionA" class="input" title="Bag A を選択"></select>
                <select id="selSrcUnionB" class="input" title="Bag B を選択"></select>
              </div>
              <div class="inline">
                <button id="btnUnion" class="btn" title="AとBの和集合を作成します (A ∪ B)">和集合 (Union)</button>
                <button id="btnDiff" class="btn" title="AからBに含まれる要素を除いた差集合を作成します (A - B)">差集合 (Difference)</button>
                <button id="btnIntersect" class="btn" title="AとBの両方に含まれる要素の積集合を作成します (A ∩ B)">積集合
                  (Intersection)</button>
                <button id="btnSymDiff" class="btn" title="AまたはBの片方だけに含まれる要素の集合を作成します (A △ B)">対称差 (Symmetric)</button>
              </div>
            </div>


            <div class="op-group">
              <h4>結合・直積 (Cartesian)</h4>
              <p class="muted small" style="margin: 4px 0 8px;">2つのBagの全ての組み合わせを結合します (A × B)。</p>
              <div class="inline">
                <select id="selSrcCartesianA" class="input" title="Bag A (Prefix側) を選択"></select>
                <select id="selSrcCartesianB" class="input" title="Bag B (Suffix側) を選択"></select>
              </div>
              <div class="inline">
                <input id="cartesianJoiner" class="input tight" placeholder="連結文字 (なし)" title="間に挟む文字 (例: の, -)" />
                <label class="muted small">Limit <input id="cartesianLimit" type="number" min="1" class="input tight"
                    value="10000" title="生成数の上限 (安全のため)"></label>
                <button id="btnCartesian" class="btn" title="直積結合を実行します">結合 (Join)</button>
              </div>
            </div>

            <div class="op-group">
              <h4>包含フィルタ</h4>
              <p class="muted small" style="margin: 4px 0 8px;">辞書（Lookup Bag）に含まれる単語のみを残します。</p>
              <div class="inline">
                <select id="selSrcFlt" class="input" title="フィルタ対象のBagを選択"></select>
                <select id="selLkpFlt" class="input" title="辞書として使うBagを選択"></select>
                <button id="btnFlt" class="btn" title="辞書Bagに含まれている単語だけを残します">filter_in（交差）</button>
              </div>
              <div class="inline">
                <label class="muted small" title="処理前に対象Bagをひらがな化します"><input type="checkbox" id="ckPreNormFltSrc"> Bag
                  をひらがな化</label>
                <label class="muted small" title="処理前に辞書Bagをひらがな化します"><input type="checkbox" id="ckPreNormFltLookup">
                  Lookup をひらがな化</label>
              </div>
            </div>

            <div class="op-group">
              <h4>長さフィルタ</h4>
              <p class="muted small" style="margin: 4px 0 8px;">文字数が指定範囲内の単語のみを抽出します。</p>
              <select id="selSrcLen" class="input" title="入力とするBagを選択"></select>
              <div class="inline">
                <label class="muted small">min <input id="lenMin" type="number" min="0" class="input tight" value="1"
                    title="最小文字数"></label>
                <label class="muted small">max <input id="lenMax" type="number" min="1" class="input tight" value="10"
                    title="最大文字数"></label>
                <button id="btnLengthFilter" class="btn" title="指定した長さの範囲内の単語を抽出します">適用</button>
              </div>
              <div class="inline">
                <label class="muted small" title="処理前に入力Bagをひらがな化します"><input type="checkbox" id="ckPreNormLen"> Bag
                  をひらがな化</label>
              </div>
            </div>

            <div class="op-group">
              <h4>前後一致フィルタ</h4>
              <p class="muted small" style="margin: 4px 0 8px;">前方一致（接頭辞）または後方一致（接尾辞）でフィルタします。</p>
              <select id="selSrcAffix" class="input" title="入力とするBagを選択"></select>
              <div class="inline">
                <label class="muted small" title="処理前に入力Bagをひらがな化します"><input type="checkbox" id="ckPreNormAffix"> Bag
                  をひらがな化</label>
              </div>
              <div class="inline">
                <input id="prefixValue" class="input" placeholder="前方一致（prefix）" title="開始文字列を指定" />
                <button id="btnPrefix" class="btn" title="指定した文字列で始まる単語を抽出します">prefix filter</button>
              </div>
              <div class="inline">
                <input id="suffixValue" class="input" placeholder="後方一致（suffix）" title="終了文字列を指定" />
                <button id="btnSuffix" class="btn" title="指定した文字列で終わる単語を抽出します">suffix filter</button>
              </div>
            </div>

            <div class="op-group">
              <h4>部分一致フィルタ</h4>
              <p class="muted small" style="margin: 4px 0 8px;">指定した文字列を含む単語を抽出します。</p>
              <select id="selSrcContains" class="input" title="入力とするBagを選択"></select>
              <div class="inline">
                <label class="muted small" title="処理前に入力Bagをひらがな化します"><input type="checkbox" id="ckPreNormContains"> Bag
                  をひらがな化</label>
              </div>
              <div class="inline">
                <input id="containsValue" class="input" placeholder="入力文字列を含む語" title="検索したい文字列" />
                <button id="btnContains" class="btn" title="指定した文字列を含む単語を抽出します">contains filter</button>
              </div>
            </div>

            <div class="op-group">
              <h4>正規表現フィルタ</h4>
              <p class="muted small" style="margin: 4px 0 8px;">正規表現パターンにマッチする単語を抽出します。</p>
              <select id="selSrcRegex" class="input" title="入力とするBagを選択"></select>
              <div class="inline">
                <input id="regexPattern" class="input" placeholder="例：^[ぁ-ゔ]{2,3}$" title="正規表現パターンを入力" />
                <label class="muted small" title="マッチしないものを抽出する場合にチェック"><input type="checkbox" id="regexInvert">
                  逆一致</label>
                <button id="btnRegex" class="btn" title="正規表現でフィルタします">filter_regex</button>
              </div>
              <div class="inline">
                <label class="muted small" title="処理前に入力Bagをひらがな化します"><input type="checkbox" id="ckPreNormRegex"> Bag
                  をひらがな化</label>
              </div>
            </div>

            <div class="op-group">
              <h4>類似度フィルタ (Levenshtein)</h4>
              <p class="muted small" style="margin: 4px 0 8px;">ターゲット文字列に近い単語（編集距離が近い）を抽出します。</p>
              <select id="selSrcSimilarity" class="input" title="入力とするBagを選択"></select>
              <div class="inline">
                <input id="similarityTarget" class="input" placeholder="ターゲット文字列" title="比較対象の単語" />
                <label class="muted small">dist <input id="similarityDist" type="number" min="0" class="input tight"
                    value="2" title="許容する最大編集距離"></label>
                <button id="btnSimilarity" class="btn" title="類似度フィルタを実行します">抽出</button>
              </div>
              <div class="inline">
                <label class="muted small" title="処理前に入力Bagをひらがな化します"><input type="checkbox" id="ckPreNormSimilarity">
                  Bag
                  をひらがな化</label>
              </div>
            </div>

            <div class="op-group">
              <h4>整形・置換</h4>
              <p class="muted small" style="margin: 4px 0 8px;">重複文字除去、置換、ソートを行います。</p>
              <select id="selSrcFormat" class="input" title="入力とするBagを選択"></select>
              <div class="inline">
                <button id="btnDedupe" class="btn" title="各単語内で重複する文字を取り除きます">重複文字除去</button>
                <button id="btnSortAsc" class="btn" title="単語を辞書順（昇順）に並べます">昇順ソート</button>
                <button id="btnSortDesc" class="btn" title="単語を辞書順（降順）に並べます">降順ソート</button>
              </div>
              <div class="inline">
                <input id="replaceFrom" class="input" placeholder="置換 from" title="置換されれる文字列" />
                <input id="replaceTo" class="input" placeholder="to" title="置換後の文字列" />
                <button id="btnReplace" class="btn" title="文字列置換を実行します">置換</button>
              </div>
            </div>

            <div class="op-group">
              <h4>n-gram 抽出</h4>
              <p class="muted small" style="margin: 4px 0 8px;">単語からN文字ごとの切り出しを行い、新しいBagを作ります。</p>
              <select id="selSrcNgram" class="input" title="入力とするBagを選択"></select>
              <div class="inline">
                <label class="muted small">n <input id="ngramN" type="number" min="1" class="input tight" value="2"
                    title="切り出す文字数"></label>
                <button id="btnNgram" class="btn" title="N-gram抽出を実行します">抽出</button>
              </div>
            </div>

            <div class="op-group">
              <h4>サンプリング</h4>
              <p class="muted small" style="margin: 4px 0 8px;">Bagからランダムに指定数を抽出します。</p>
              <select id="selSrcSample" class="input" title="入力とするBagを選択"></select>
              <div class="inline">
                <label class="muted small">count <input id="sampleCount" type="number" min="1" class="input tight"
                    value="20" title="抽出数"></label>
                <input id="sampleSeed" class="input" placeholder="seed（任意）" title="乱数シード（固定すると再現性が出ます）" />
                <button id="btnSample" class="btn" title="ランダムサンプリングを実行します">sample</button>
              </div>
            </div>
          </div>
        </section>

        <section class="tab-panel" data-panel="export">
          <h3>2) Export</h3>
          <div class="panel-grid">
            <select id="selExport" class="input"></select>
            <div class="export-actions">
              <button class="btn" data-format="txt">TXT</button>
              <button class="btn" data-format="csv">CSV</button>
              <button class="btn primary" data-format="json">JSON</button>
            </div>
            <div class="muted small">選択した Bag をダウンロードします。CSV では 1 行に 1 語、JSON では <span class="mono">{"name":…,
                "items":[…]}</span> を出力。</div>
          </div>
        </section>
      </aside>

      <main class="main card">
        <div>
          <h2>Bag 一覧</h2>
          <div class="subtitle small">プレビューを開くと編集・コピーができます。</div>
        </div>
        <button id="btnApplyAll" class="btn ok">全バッグを再適用</button>
        <div id="bagsArea" class="bag-list"></div>
      </main>

      <aside class="log-panel card">
        <div class="log-header">
          <h3>操作履歴</h3>
          <div class="history-actions">
            <button id="btnUndo" class="btn ghost" disabled>Undo</button>
            <button id="btnRedo" class="btn ghost" disabled>Redo</button>
          </div>
        </div>
        <div id="opLog" class="log-body"></div>
        <div>
          <h3>ログ</h3>
        </div>
        <div id="log" class="log-body"></div>
      </aside>
    </div>
  </div>

  <script>
    /* ====== 共通ユーティリティ ====== */
    const nowISO = () => new Date().toISOString().replace(/\.\d{3}Z$/, 'Z');
    const uniq = a => Array.from(new Set(a));
    const normNFKC = s => (s || "").normalize('NFKC').trim();
    const el = q => document.querySelector(q);
    const parseIntSafe = (value, fallback = 0) => {
      const n = Number.parseInt(value, 10);
      return Number.isFinite(n) ? n : fallback;
    };
    function log(msg) {
      const host = el('#log');
      if (!host) return;
      const div = document.createElement('div');
      div.className = 'log-entry';
      div.textContent = `[${nowISO()}] ${msg}`;
      host.prepend(div);
      while (host.children.length > 150) host.removeChild(host.lastChild);
    }
    function appendOpLog(msg) {
      const host = el('#opLog');
      if (!host) return;
      const div = document.createElement('div');
      div.className = 'log-entry';
      div.textContent = `[${nowISO()}] ${msg}`;
      host.prepend(div);
      while (host.children.length > 150) host.removeChild(host.lastChild);
    }

    /* Levenshtein Distance */
    function levenshtein(s, t) {
      if (!s) return t.length;
      if (!t) return s.length;
      const d = [];
      const n = s.length;
      const m = t.length;
      for (let i = 0; i <= n; i++) d[i] = [i];
      for (let j = 0; j <= m; j++) d[0][j] = j;
      for (let i = 1; i <= n; i++) {
        for (let j = 1; j <= m; j++) {
          const cost = s[i - 1] === t[j - 1] ? 0 : 1;
          d[i][j] = Math.min(d[i - 1][j] + 1, d[i][j - 1] + 1, d[i - 1][j - 1] + cost);
        }
      }
      return d[n][m];
    }

    function setsAreEqual(a, b) {
      if (a === b) return true;
      if (!(a instanceof Set) || !(b instanceof Set)) return false;
      if (a.size !== b.size) return false;
      for (const value of a) {
        if (!b.has(value)) return false;
      }
      return true;
    }

    function findBagStatusElement(bagId) {
      return document.querySelector(`.bag-card[data-id="${bagId}"] [data-k="status"]`);
    }

    function setBagStatusMessage(bagId, message) {
      const statusEl = findBagStatusElement(bagId);
      if (statusEl) {
        const text = message || '';
        statusEl.textContent = text;
        statusEl.title = text;
      }
    }

    function describeBagLifecycle(bag) {
      if (bag?.meta?.reapply_status) return bag.meta.reapply_status;
      if (bag?.meta?.reapplied_at) return `↻ ${bag.meta.reapplied_at}`;
      if (bag?.meta?.updated_at) return `✎ ${bag.meta.updated_at}`;
      if (bag?.meta?.created_at) return `＋ ${bag.meta.created_at}`;
      return '';
    }
    function setSelectOptions(sel, opts) {
      if (!sel) return;
      const v = sel.value;
      sel.innerHTML = '';
      for (const o of opts) {
        const op = document.createElement('option');
        op.value = o.value;
        op.textContent = o.label;
        sel.appendChild(op);
      }
      if (opts.length) {
        sel.value = v && opts.some(o => o.value === v) ? v : opts[opts.length - 1].value;
      }
    }

    /* ====== Kuroshiro（かな正規化） ====== */
    let K = null, kuroReady = false;
    async function ensureKuro() {
      if (kuroReady) return;
      K = new window.Kuroshiro();
      const Analyzer = window.Kuroshiro.Analyzer.KuromojiAnalyzer;
      await K.init(new Analyzer({ dictPath: 'https://cdn.jsdelivr.net/npm/kuromoji@0.1.2/dict' }));
      kuroReady = true;
    }
    function katakanaToHiragana(value) {
      if (!value) return '';
      return value.replace(/[\u30A1-\u30FA\u30FD\u30FE]/g, ch => {
        const code = ch.charCodeAt(0);
        if (code === 0x30FD) return 'ゝ'; // ヽ → ゝ
        if (code === 0x30FE) return 'ゞ'; // ヾ → ゞ
        return String.fromCharCode(code - 0x60);
      });
    }

    function normalizeKatakanaFallback(value) {
      if (!value) return '';
      return katakanaToHiragana(value);
    }

    function safeWanakanaConvert(method, value) {
      const wk = window.wanakana;
      if (wk && typeof wk[method] === 'function') {
        return wk[method](value);
      }
      if (method === 'toHiragana') {
        return normalizeKatakanaFallback(value);
      }
      return value;
    }
    async function toHiragana(s) {
      if (!s) return '';
      try {
        await ensureKuro();
        return await K.convert(normNFKC(s), { to: 'hiragana', mode: 'spaced' });
      } catch {
        return safeWanakanaConvert('toHiragana', normNFKC(s));
      }
    }
    async function toKatakana(s) {
      if (!s) return '';
      try {
        await ensureKuro();
        return await K.convert(normNFKC(s), { to: 'katakana', mode: 'spaced' });
      } catch {
        return safeWanakanaConvert('toKatakana', normNFKC(s));
      }
    }
    async function toRomaji(s) {
      if (!s) return '';
      try {
        await ensureKuro();
        return await K.convert(normNFKC(s), { to: 'romaji', mode: 'spaced' });
      } catch {
        return safeWanakanaConvert('toRomaji', normNFKC(s));
      }
      return out;
    }



    /* ====== Bag / Registry ====== */
    let _nextId = 0;
    class Bag {
      constructor(name, items, meta = {}) {
        this.id = _nextId++;
        this.name = name || `bag#${this.id}`;
        this.items = new Set(items || []);
        this.meta = Object.assign({}, meta);
        if (!this.meta.created_at) this.meta.created_at = nowISO();
        this.meta.size = this.items.size;
      }
      label() { return `[${this.id}] ${this.name} (${this.items.size})`; }
    }
    class BagRegistry {
      constructor() { this._bags = []; }
      add(b) { this._bags.push(b); return b.id; }
      get(id) { return this._bags.find(x => x.id === Number(id)); }
      all() { return this._bags.slice(); }
      indexOf(id) { return this._bags.findIndex(x => x.id === Number(id)); }
      remove(id) {
        const idx = this.indexOf(id);
        if (idx < 0) return false;
        this._bags.splice(idx, 1);
        return true;
      }
      clone(id, nameSuffix = ' copy') {
        const src = this.get(id);
        if (!src) return null;
        const clonedMeta = Object.assign({}, src.meta, {
          cloned_from: src.id,
          cloned_op: src.meta?.op || null,
          op: 'clone',
          src: src.id
        });
        delete clonedMeta.reapply_status;
        delete clonedMeta.reapply_error;
        const clone = new Bag(`${src.name}${nameSuffix}`, Array.from(src.items), clonedMeta);
        this.add(clone);
        return clone;
      }
      moveRelative(sourceId, targetId, placeBefore = false) {
        const fromIdx = this.indexOf(sourceId);
        const targetIdx = this.indexOf(targetId);
        if (fromIdx < 0 || targetIdx < 0 || sourceId === targetId) return false;
        const [bag] = this._bags.splice(fromIdx, 1);
        let insertIdx = this.indexOf(targetId);
        if (insertIdx < 0) return false;
        if (!placeBefore) insertIdx += 1;
        this._bags.splice(insertIdx, 0, bag);
        return true;
      }
      choices() { return this._bags.map(b => ({ label: b.label(), value: String(b.id) })); }
      serialize() {
        return {
          nextId: _nextId,
          bags: this._bags.map(b => ({
            id: b.id,
            name: b.name,
            items: Array.from(b.items),
            meta: Object.assign({}, b.meta)
          }))
        };
      }
      restore(snapshot) {
        this._bags = snapshot.bags.map(data => {
          const bag = new Bag(data.name, data.items, Object.assign({}, data.meta));
          bag.id = data.id;
          bag.meta.size = bag.items.size;
          return bag;
        });
        _nextId = snapshot.nextId;
      }
    }
    const REG = new BagRegistry();

    /* ====== 履歴管理 ====== */
    const history = [];
    let historyIndex = -1;
    function captureState() {
      const snapshot = REG.serialize();
      history.splice(historyIndex + 1);
      history.push(snapshot);
      historyIndex = history.length - 1;
      updateUndoRedoButtons();
    }
    function restoreFromHistory() {
      if (historyIndex < 0 || historyIndex >= history.length) return;
      const snapshot = history[historyIndex];
      REG.restore(snapshot);
      renderBags();
      applyChoices();
      updateUndoRedoButtons();
    }
    function updateUndoRedoButtons() {
      const undoBtn = el('#btnUndo');
      const redoBtn = el('#btnRedo');
      if (undoBtn) undoBtn.disabled = historyIndex <= 0;
      if (redoBtn) redoBtn.disabled = historyIndex >= history.length - 1;
    }
    function initHistory() {
      captureState();
    }

  </script>
  <script src="operations.js"></script>
  <script>
    /* ====== JSON列挙・ロード（bag/*.json） ====== */
    const BAG_DIR = './bag/';
    function applyChoices() {
      const choices = REG.choices();
      const ids = ['#selSrcNorm', '#selSrcTransform', '#selSrcDel', '#selSrcFlt', '#selLkpFlt', '#selSrcUnionA',
        '#selSrcUnionB', '#selSrcLen', '#selSrcAffix', '#selSrcContains', '#selSrcRegex', '#selSrcFormat',
        '#selSrcNgram', '#selSrcSample', '#selExport', '#selSrcCartesianA', '#selSrcCartesianB', '#selSrcAppend',
        '#selSrcAnagram', '#selSrcSimilarity'];
      ids.forEach(id => setSelectOptions(el(id), choices));
    }
    function addBagFromWords(name, words, meta) {
      const b = new Bag(name, uniq(words.map(normNFKC).filter(Boolean)), meta || {});
      REG.add(b);
      applyChoices();
      renderBags();
      captureState();
      appendOpLog(`+ Bag [${b.id}] '${b.name}' size=${b.items.size}`);
      return b;
    }

    async function listJson() {
      const sel = el('#selFile');
      if (!sel) return;
      sel.innerHTML = '';
      try {
        const r = await fetch(BAG_DIR + '_files.txt', { cache: 'no-cache' });
        if (r.ok) {
          const t = await r.text();
          const files = t.split(/\r?\n/).map(s => s.trim()).filter(s => s && /\.json$/i.test(s));
          if (files.length) {
            setSelectOptions(sel, files.map(f => ({ label: f, value: f })));
            log('一覧: _files.txt から ' + files.length + ' 件');
            return;
          }
        }
      } catch (_) { }
      try {
        const r = await fetch(BAG_DIR, { cache: 'no-cache' });
        if (!r.ok) throw new Error('HTTP ' + r.status);
        const html = await r.text();
        const files = [...html.matchAll(/href="([^"]+?\.json)"/gi)].map(m =>
          decodeURIComponent(m[1].split('/').pop()));
        const files2 = [...html.matchAll(/href='([^']+?\.json)'/gi)].map(m =>
          decodeURIComponent(m[1].split('/').pop()));
        const all = uniq([...(files || []), ...(files2 || [])]);
        if (all.length) {
          setSelectOptions(sel, all.map(f => ({ label: f, value: f })));
          log('一覧: ディレクトリ HTML から ' + all.length + ' 件');
          return;
        }
        throw new Error('解析失敗');
      } catch (e) {
        log('列挙失敗: ' + e.message + '（bag/_files.txt を置くか、HTTP サーバのディレクトリ一覧を有効にしろ）');
      }
    }
    async function loadSelectedJson() {
      const sel = el('#selFile');
      const f = sel && sel.value;
      if (!f) { log('ファイル未選択'); return; }
      try {
        const r = await fetch(BAG_DIR + f, { cache: 'no-cache' });
        if (!r.ok) throw new Error('HTTP ' + r.status);
        const raw = await r.text();
        const head = raw.trim()[0];
        if (head !== '[' && head !== '{') throw new Error('JSON ではなく HTML 等が返っている');
        const data = JSON.parse(raw);
        const words = [];
        for (const obj of (Array.isArray(data) ? data : [data])) {
          if (obj && Array.isArray(obj.lemmas)) words.push(...obj.lemmas);
        }
        addBagFromWords(f.replace(/\.json$/i, ''), words, { from: 'json', format: 'lemmas' });
        log(`読み込み OK: ${f} | 語数=${words.length}`);
      } catch (e) { log('読み込み失敗: ' + e.message); }
    }

    /* ====== 手動アップロード / 貼り付け ====== */
    el('#filePick')?.addEventListener('change', async (ev) => {
      const f = ev.target.files[0]; if (!f) return;
      try {
        const txt = await f.text();
        const head = txt.trim()[0];
        if (head !== '[' && head !== '{') throw new Error('JSON でない');
        const data = JSON.parse(txt);
        const words = [];
        for (const obj of (Array.isArray(data) ? data : [data])) {
          if (obj && Array.isArray(obj.lemmas)) words.push(...obj.lemmas);
        }
        addBagFromWords(f.name.replace(/\.json$/i, ''), words, { from: 'upload', format: 'lemmas' });
        log(`手動読み込み OK: ${f.name} | 語数=${words.length}`);
      } catch (e) { log('手動読み込み失敗: ' + e.message); }
    });
    el('#btnMakeBagFromText')?.addEventListener('click', () => {
      const name = normNFKC(el('#bagNameInput').value) || 'input bag';
      const words = uniq(el('#pasteArea').value.split(/\r?\n/).map(s => normNFKC(s)).filter(Boolean));
      if (!words.length) {
        el('#importLog').textContent += (el('#importLog').textContent ? '\n' : '') + '空入力';
        return;
      }
      addBagFromWords(name, words, { from: 'paste', normalized: 'NFKC' });
    });

    /* ====== 操作ボタン ====== */
    el('#btnNorm')?.addEventListener('click', async () => {
      const src = REG.get(el('#selSrcNorm').value); if (!src) return;
      appendOpLog(`normalize(hiragana)… [${src.id}] ${src.name}`);
      const nb = await op_normalize_hiragana(src);
      REG.add(nb); applyChoices(); renderBags(); captureState();
      appendOpLog(`→ NewBag [${nb.id}] size=${nb.items.size}`);
    });
    el('#btnKatakana')?.addEventListener('click', async () => {
      const src = REG.get(el('#selSrcNorm').value); if (!src) return;
      appendOpLog(`normalize(katakana)… [${src.id}] ${src.name}`);
      const nb = await op_normalize_katakana(src);
      REG.add(nb); applyChoices(); renderBags(); captureState();
      appendOpLog(`→ NewBag [${nb.id}] size=${nb.items.size}`);
    });
    el('#btnRomaji')?.addEventListener('click', async () => {
      const src = REG.get(el('#selSrcTransform').value); if (!src) return;
      appendOpLog(`to_romaji … [${src.id}] ${src.name}`);
      const nb = await op_to_romaji(src);
      REG.add(nb); applyChoices(); renderBags(); captureState();
      appendOpLog(`→ NewBag [${nb.id}] size=${nb.items.size}`);
    });
    el('#btnUpper')?.addEventListener('click', () => {
      const src = REG.get(el('#selSrcTransform').value); if (!src) return;
      appendOpLog(`to_upper … [${src.id}] ${src.name}`);
      const nb = op_to_upper(src);
      REG.add(nb); applyChoices(); renderBags(); captureState();
      appendOpLog(`→ NewBag [${nb.id}] size=${nb.items.size}`);
    });
    el('#btnLower')?.addEventListener('click', () => {
      const src = REG.get(el('#selSrcTransform').value); if (!src) return;
      appendOpLog(`to_lower … [${src.id}] ${src.name}`);
      const nb = op_to_lower(src);
      REG.add(nb); applyChoices(); renderBags(); captureState();
      appendOpLog(`→ NewBag [${nb.id}] size=${nb.items.size}`);
    });
    el('#btnReverse')?.addEventListener('click', () => {
      const src = REG.get(el('#selSrcTransform').value); if (!src) return;
      appendOpLog(`reverse … [${src.id}] ${src.name}`);
      const nb = op_reverse(src);
      REG.add(nb); applyChoices(); renderBags(); captureState();
      appendOpLog(`→ NewBag [${nb.id}] size=${nb.items.size}`);
    });
    el('#btnDel')?.addEventListener('click', async () => {
      const src = REG.get(el('#selSrcDel').value); if (!src) return;
      const chars = el('#delChars').value || '';
      const normIn = el('#ckNormDel').checked;
      const normBag = el('#ckPreNormDel').checked;
      appendOpLog(`delete chars "${chars}" (normalize_input=${normIn}, bag_hira=${normBag}) … [${src.id}]
            ${src.name}`);
      const nb = await op_delete_chars(src, chars, normIn, normBag);
      REG.add(nb); applyChoices(); renderBags(); captureState();
      appendOpLog(`→ NewBag [${nb.id}] size=${nb.items.size}`);
    });
    el('#btnFlt')?.addEventListener('click', async () => {
      const src = REG.get(el('#selSrcFlt').value), lkp = REG.get(el('#selLkpFlt').value);
      if (!src || !lkp) return;
      const normSrc = el('#ckPreNormFltSrc').checked;
      const normLookup = el('#ckPreNormFltLookup').checked;
      appendOpLog(`filter_in lookup=[${lkp.id}:${lkp.name}] (bag_hira=${normSrc}, lookup_hira=${normLookup}) …
            [${src.id}] ${src.name}`);
      const nb = await op_filter_in(src, lkp, normSrc, normLookup);
      REG.add(nb); applyChoices(); renderBags(); captureState();
      appendOpLog(`→ NewBag [${nb.id}] size=${nb.items.size}`);
    });
    el('#btnUnion')?.addEventListener('click', () => {
      const a = REG.get(el('#selSrcUnionA').value);
      const b = REG.get(el('#selSrcUnionB').value);
      if (!a || !b) return;
      appendOpLog(`union … [${a.id}] ${a.name} + [${b.id}] ${b.name}`);
      const nb = op_union(a, b);
      REG.add(nb); applyChoices(); renderBags(); captureState();
      appendOpLog(`→ NewBag [${nb.id}] size=${nb.items.size}`);
    });
    el('#btnDiff')?.addEventListener('click', () => {
      const a = REG.get(el('#selSrcUnionA').value);
      const b = REG.get(el('#selSrcUnionB').value);
      if (!a || !b) return;
      appendOpLog(`difference … [${a.id}] ${a.name} - [${b.id}] ${b.name}`);
      const nb = op_difference(a, b);
      REG.add(nb); applyChoices(); renderBags(); captureState();
      appendOpLog(`→ NewBag [${nb.id}] size=${nb.items.size}`);
    });
    el('#btnIntersect')?.addEventListener('click', () => {
      const a = REG.get(el('#selSrcUnionA').value);
      const b = REG.get(el('#selSrcUnionB').value);
      if (!a || !b) return;
      appendOpLog(`intersection … [${a.id}] ${a.name} ∩ [${b.id}] ${b.name}`);
      const nb = op_intersection(a, b);
      REG.add(nb); applyChoices(); renderBags(); captureState();
      appendOpLog(`→ NewBag [${nb.id}] size=${nb.items.size}`);
    });
    el('#btnSymDiff')?.addEventListener('click', () => {
      const a = REG.get(el('#selSrcUnionA').value);
      const b = REG.get(el('#selSrcUnionB').value);
      if (!a || !b) return;
      appendOpLog(`symmetric difference … [${a.id}] ${a.name} △ [${b.id}] ${b.name}`);
      const nb = op_symmetric_difference(a, b);
      REG.add(nb); applyChoices(); renderBags(); captureState();
      appendOpLog(`→ NewBag [${nb.id}] size=${nb.items.size}`);
    });
    el('#btnLengthFilter')?.addEventListener('click', async () => {
      const src = REG.get(el('#selSrcLen').value);
      if (!src) return;
      const min = Math.max(0, parseIntSafe(el('#lenMin').value, 0));
      const max = Math.max(min, parseIntSafe(el('#lenMax').value, min));
      const normBag = el('#ckPreNormLen').checked;
      appendOpLog(`filter length [${min}, ${max}] (bag_hira=${normBag}) … [${src.id}] ${src.name}`);
      const nb = await op_filter_length(src, min, max, normBag);
      REG.add(nb); applyChoices(); renderBags(); captureState();
      appendOpLog(`→ NewBag [${nb.id}] size=${nb.items.size}`);
    });
    el('#btnPrefix')?.addEventListener('click', async () => {
      const src = REG.get(el('#selSrcAffix').value);
      if (!src) return;
      const prefixRaw = el('#prefixValue').value;
      const prefix = normNFKC(prefixRaw);
      if (!prefix) { log('prefix を入力してください'); return; }
      const normBag = el('#ckPreNormAffix').checked;
      appendOpLog(`filter prefix "${prefix}" (bag_hira=${normBag}) … [${src.id}] ${src.name}`);
      const nb = await op_filter_prefix(src, prefixRaw, normBag);
      REG.add(nb); applyChoices(); renderBags(); captureState();
      appendOpLog(`→ NewBag [${nb.id}] size=${nb.items.size}`);
    });
    el('#btnSuffix')?.addEventListener('click', async () => {
      const src = REG.get(el('#selSrcAffix').value);
      if (!src) return;
      const suffixRaw = el('#suffixValue').value;
      const suffix = normNFKC(suffixRaw);
      if (!suffix) { log('suffix を入力してください'); return; }
      const normBag = el('#ckPreNormAffix').checked;
      appendOpLog(`filter suffix "${suffix}" (bag_hira=${normBag}) … [${src.id}] ${src.name}`);
      const nb = await op_filter_suffix(src, suffixRaw, normBag);
      REG.add(nb); applyChoices(); renderBags(); captureState();
      appendOpLog(`→ NewBag [${nb.id}] size=${nb.items.size}`);
    });
    el('#btnContains')?.addEventListener('click', async () => {
      const src = REG.get(el('#selSrcContains').value);
      if (!src) return;
      const needleRaw = el('#containsValue').value;
      const needle = normNFKC(needleRaw);
      if (!needle) { log('検索文字列を入力してください'); return; }
      const normBag = el('#ckPreNormContains').checked;
      appendOpLog(`filter contains "${needle}" (bag_hira=${normBag}) … [${src.id}] ${src.name}`);
      const nb = await op_filter_contains(src, needleRaw, normBag);
      REG.add(nb); applyChoices(); renderBags(); captureState();
      appendOpLog(`→ NewBag [${nb.id}] size=${nb.items.size}`);
    });
    el('#btnRegex')?.addEventListener('click', async () => {
      const src = REG.get(el('#selSrcRegex').value);
      const pattern = el('#regexPattern').value;
      const invert = el('#regexInvert').checked;
      if (!src) return;
      if (!pattern) { log('正規表現を入力してください'); return; }
      const invertLabel = invert ? ' (invert)' : '';
      const normBag = el('#ckPreNormRegex').checked;
      appendOpLog(`filter_regex /${pattern}/${invertLabel} (bag_hira=${normBag}) … [${src.id}] ${src.name}`);
      let nb;
      try {
        nb = await op_filter_regex(src, pattern, invert, normBag);
      } catch (e) {
        log(`正規表現エラー: ${e.message}`);
        appendOpLog('× 正規表現エラー');
        return;
      }
      REG.add(nb); applyChoices(); renderBags(); captureState();
      appendOpLog(`→ NewBag [${nb.id}] size=${nb.items.size}`);
    });
    el('#btnDedupe')?.addEventListener('click', () => {
      const src = REG.get(el('#selSrcFormat').value); if (!src) return;
      appendOpLog(`dedupe_chars … [${src.id}] ${src.name}`);
      const nb = op_dedupe_chars(src);
      REG.add(nb); applyChoices(); renderBags(); captureState();
      appendOpLog(`→ NewBag [${nb.id}] size=${nb.items.size}`);
    });
    el('#btnSortAsc')?.addEventListener('click', () => {
      const src = REG.get(el('#selSrcFormat').value); if (!src) return;
      appendOpLog(`sort asc … [${src.id}] ${src.name}`);
      const nb = op_sort(src, 'asc');
      REG.add(nb); applyChoices(); renderBags(); captureState();
      appendOpLog(`→ NewBag [${nb.id}] size=${nb.items.size}`);
    });
    el('#btnSortDesc')?.addEventListener('click', () => {
      const src = REG.get(el('#selSrcFormat').value); if (!src) return;
      appendOpLog(`sort desc … [${src.id}] ${src.name}`);
      const nb = op_sort(src, 'desc');
      REG.add(nb); applyChoices(); renderBags(); captureState();
      appendOpLog(`→ NewBag [${nb.id}] size=${nb.items.size}`);
    });
    el('#btnReplace')?.addEventListener('click', () => {
      const src = REG.get(el('#selSrcFormat').value); if (!src) return;
      const fromRaw = el('#replaceFrom').value;
      const toRaw = el('#replaceTo').value || '';
      const from = normNFKC(fromRaw);
      const to = normNFKC(toRaw);
      if (!from) { log('置換対象 (from) を入力してください'); return; }
      appendOpLog(`replace "${from}" → "${to}" … [${src.id}] ${src.name}`);
      const nb = op_replace(src, fromRaw, toRaw);
      REG.add(nb); applyChoices(); renderBags(); captureState();
      appendOpLog(`→ NewBag [${nb.id}] size=${nb.items.size}`);
    });
    el('#btnNgram')?.addEventListener('click', () => {
      const src = REG.get(el('#selSrcNgram').value);
      if (!src) return;
      const n = Math.max(1, parseIntSafe(el('#ngramN').value, 2));
      appendOpLog(`ngrams n=${n} … [${src.id}] ${src.name}`);
      const nb = op_ngrams(src, n);
      REG.add(nb); applyChoices(); renderBags(); captureState();
      appendOpLog(`→ NewBag [${nb.id}] size=${nb.items.size}`);
    });
    el('#btnSample')?.addEventListener('click', () => {
      const src = REG.get(el('#selSrcSample').value);
      if (!src) return;
      const count = Math.max(1, parseIntSafe(el('#sampleCount').value, 20));
      const seedRaw = normNFKC(el('#sampleSeed').value);
      const seedInfo = seedRaw ? ` seed=${seedRaw}` : '';
      appendOpLog(`sample count=${count}${seedInfo} … [${src.id}] ${src.name}`);
      const nb = op_sample(src, count, seedRaw || null);
      REG.add(nb); applyChoices(); renderBags(); captureState();
      appendOpLog(`→ NewBag [${nb.id}] size=${nb.items.size}`);
    });

    /* ====== Export ====== */
    function downloadBag(bag, format) {
      if (!bag) return;
      let blob, filename;
      const stamp = nowISO().replace(/[:T-]/g, '').slice(0, 14);
      if (format === 'json') {
        const data = { name: bag.name, id: bag.id, items: Array.from(bag.items) };
        blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        filename = `${bag.name || 'bag'}_${stamp}.json`;
      } else if (format === 'csv') {
        blob = new Blob([Array.from(bag.items).join('\n')], { type: 'text/csv' });
        filename = `${bag.name || 'bag'}_${stamp}.csv`;
      } else {
        blob = new Blob([Array.from(bag.items).join('\n')], { type: 'text/plain' });
        filename = `${bag.name || 'bag'}_${stamp}.txt`;
      }
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = filename;
      a.click();
      URL.revokeObjectURL(a.href);
      log(`Export ${format.toUpperCase()}: ${filename}`);
    }
    document.querySelectorAll('.export-actions button').forEach(btn => {
      btn.addEventListener('click', () => {
        const bag = REG.get(el('#selExport').value);
        if (!bag) { log('Export 対象が選択されていません'); return; }
        downloadBag(bag, btn.dataset.format);
      });
    });

    /* ====== Undo / Redo ====== */
    el('#btnUndo')?.addEventListener('click', () => {
      if (historyIndex <= 0) return; historyIndex -= 1; restoreFromHistory(); appendOpLog('⮪ Undo');
    });
    el('#btnRedo')?.addEventListener('click', () => {
      if (historyIndex >= history.length - 1) return;
      historyIndex += 1;
      restoreFromHistory();
      appendOpLog('⮫ Redo');
    });

    let dragSourceId = null;

    /* ====== Bag一覧（編集/適用 + 範囲/全表示） ====== */
    function renderBags() {
      const host = el('#bagsArea');
      if (!host) return;
      dragSourceId = null;
      host.innerHTML = '';
      for (const b of REG.all()) {
        const details = document.createElement('details');
        details.className = 'bag-card';
        details.dataset.id = b.id;
        details.draggable = true;
        const sum = document.createElement('summary');
        sum.innerHTML = `<div class="bag-title">[${b.id}] ${b.name}</div>
              <div class="muted small">size=${b.items.size} | op=${b.meta.op || 'root'} | norm=${b.meta.normalized ||
          '-'}</div>`;
        details.appendChild(sum);

        const meta = document.createElement('div');
        meta.className = 'bag-meta';
        meta.textContent = Object.entries(b.meta).map(([k, v]) => `${k}: ${v}`).join('\n');
        details.appendChild(meta);

        const bar = document.createElement('div');
        bar.className = 'preview-bar';
        bar.innerHTML = `
              <span class="muted small badge">Preview</span>
              <label class="muted small">offset <input class="input tight" type="number" min="0" value="0"
                  data-k="off"></label>
              <label class="muted small">limit <input class="input tight" type="number" min="1" value="200"
                  data-k="lim"></label>
              <label class="muted small"><input type="checkbox" data-k="all"> 全表示</label>
              <button class="btn ghost" data-k="copy">クリップボード</button>
              <button class="btn" data-k="edit">編集モード</button>
              <button class="btn ok" data-k="apply" disabled>編集を適用</button>
              <span class="muted mono small" data-k="count"></span>
              `;
        details.appendChild(bar);

        const ta = document.createElement('textarea');
        ta.className = 'preview mono';
        ta.rows = 10;
        ta.readOnly = true;
        details.appendChild(ta);

        const offEl = bar.querySelector('input[data-k="off"]');
        const limEl = bar.querySelector('input[data-k="lim"]');
        const allEl = bar.querySelector('input[data-k="all"]');
        const copyBtn = bar.querySelector('[data-k="copy"]');
        const editBtn = bar.querySelector('[data-k="edit"]');
        const applyBtn = bar.querySelector('[data-k="apply"]');
        const cntEl = bar.querySelector('[data-k="count"]');
        const copyOriginalLabel = copyBtn?.textContent || '';

        function renderRange() {
          const items = Array.from(b.items).sort((a, c) => a.localeCompare(c, 'ja'));
          cntEl.textContent = `total=${items.length}`;
          let off = Math.max(0, parseInt(offEl.value || 0, 10));
          let lim = Math.max(1, parseInt(limEl.value || 200, 10));
          if (allEl.checked) { off = 0; lim = items.length; }
          ta.value = items.slice(off, off + lim).join('\n');
        }
        offEl.addEventListener('input', renderRange);
        limEl.addEventListener('input', renderRange);
        allEl.addEventListener('change', renderRange);
        copyBtn.addEventListener('click', async () => {
          try {
            await navigator.clipboard.writeText(ta.value);
            copyBtn.textContent = 'コピー済み';
            setTimeout(() => {
              copyBtn.textContent = copyOriginalLabel;
            }, 1200);
          } catch { }
        });

        let editing = false;
        editBtn.addEventListener('click', () => {
          editing = !editing;
          ta.readOnly = !editing;
          editBtn.textContent = editing ? '編集中…' : '編集モード';
          applyBtn.disabled = !editing;
          if (editing) {
            ta.value = Array.from(b.items).sort((a, c) => a.localeCompare(c, 'ja')).join('\n');
          } else {
            renderRange();
          }
        });
        applyBtn.addEventListener('click', () => {
          const lines = ta.value.split(/\r?\n/).map(normNFKC).filter(Boolean);
          b.items = new Set(uniq(lines));
          b.meta.size = b.items.size;
          b.meta.op = 'manual_edit';
          b.meta.updated_at = nowISO();
          delete b.meta.reapply_status;
          delete b.meta.reapply_error;
          ta.readOnly = true;
          editing = false;
          applyBtn.disabled = true;
          editBtn.textContent = '編集モード';
          sum.innerHTML = `<div class="bag-title">[${b.id}] ${b.name}</div>
              <div class="muted small">size=${b.items.size} | op=${b.meta.op || 'root'} | norm=${b.meta.normalized ||
            '-'}</div>`;
          renderRange();
          applyChoices();
          captureState();
          appendOpLog(`edit → Bag [${b.id}] size=${b.items.size}`);
        });

        details.addEventListener('toggle', () => { if (details.open) renderRange(); });

        const actions = document.createElement('div');
        actions.className = 'bag-actions';
        actions.innerHTML = `
              <button class="btn ghost" data-k="reapply">再適用</button>
              <button class="btn ghost" data-k="duplicate">複製</button>
              <button class="btn warn" data-k="remove">削除</button>
              <span class="muted small status" data-k="status"></span>
              `;
        details.appendChild(actions);

        const statusEl = actions.querySelector('[data-k="status"]');
        if (statusEl) {
          const statusText = describeBagLifecycle(b);
          statusEl.textContent = statusText;
          statusEl.title = statusText;
        }

        const reapplyBtn = actions.querySelector('[data-k="reapply"]');
        const duplicateBtn = actions.querySelector('[data-k="duplicate"]');
        const removeBtn = actions.querySelector('[data-k="remove"]');

        reapplyBtn.addEventListener('click', async () => {
          reapplyBtn.disabled = true;
          try {
            await reapplySeries(b.id);
          } finally {
            reapplyBtn.disabled = false;
          }
        });

        duplicateBtn.addEventListener('click', () => {
          const clone = REG.clone(b.id);
          if (!clone) return;
          applyChoices();
          renderBags();
          captureState();
          appendOpLog(`⧉ Clone → [${clone.id}] from [${b.id}] ${b.name}`);
        });

        removeBtn.addEventListener('click', () => {
          if (!window.confirm(`Bag [${b.id}] ${b.name} を削除しますか？`)) return;
          if (REG.remove(b.id)) {
            applyChoices();
            renderBags();
            captureState();
            appendOpLog(`− Remove Bag [${b.id}] ${b.name}`);
          }
        });

        details.addEventListener('dragstart', e => {
          dragSourceId = b.id;
          details.classList.add('dragging');
          e.dataTransfer?.setData('text/plain', String(b.id));
          if (e.dataTransfer) e.dataTransfer.effectAllowed = 'move';
        });
        details.addEventListener('dragend', () => {
          dragSourceId = null;
          details.classList.remove('dragging');
          details.classList.remove('drag-over');
        });
        details.addEventListener('dragover', e => {
          e.preventDefault();
          if (dragSourceId === null || dragSourceId === b.id) return;
          details.classList.add('drag-over');
          if (e.dataTransfer) e.dataTransfer.dropEffect = 'move';
        });
        details.addEventListener('dragleave', () => {
          details.classList.remove('drag-over');
        });
        details.addEventListener('drop', e => {
          e.preventDefault();
          details.classList.remove('drag-over');
          const sourceId = dragSourceId;
          dragSourceId = null;
          if (sourceId === null || sourceId === b.id) return;
          const rect = details.getBoundingClientRect();
          const placeBefore = e.clientY < rect.top + rect.height / 2; if (REG.moveRelative(sourceId, b.id,
            placeBefore)) {
              applyChoices(); renderBags(); captureState(); appendOpLog(`↕ Reorder Bag [${sourceId}]
                ${placeBefore ? '↑ before' : '↓ after'} [${b.id}]`);
          }
        }); host.appendChild(details);
      }
    }
                /*======タブ操作======*/ document.querySelectorAll('.tab-button').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.tab-button').forEach(b => b.classList.remove('active'));
        document.querySelectorAll('.tab-panel').forEach(p => p.classList.remove('active'));
        btn.classList.add('active');
        const target = document.querySelector(`.tab-panel[data-panel="${btn.dataset.tab}"]`);
        if (target) target.classList.add('active');
      });
    });

    el('#btnApplyAll')?.addEventListener('click', async () => {
      const btn = el('#btnApplyAll');
      if (!btn) return;
      btn.disabled = true;
      try {
        await reapplySeries();
      } finally {
        btn.disabled = false;
      }
    });

    el('#btnFileSelect')?.addEventListener('click', () => el('#filePick')?.click());

    /* ====== 初期化 ====== */
    // document.getElementById('btnList').onclick = listJson; // automated
    document.getElementById('btnLoad').onclick = loadSelectedJson;
    initHistory();
    (function seed() {
      const demo = ['狐', 'たぬき', '東京', '百科事典', 'コンピュータ', 'がっこう', 'バナナ', 'リンゴ', 'りんご', 'アップル'];
      addBagFromWords('seed (demo few nouns)', demo, { pos: 'n', normalized: 'NFKC only', seed: true });
    })();
    renderBags();
    applyChoices();

    /* ====== UI Toggles ====== */
    document.querySelectorAll('.op-group h4').forEach(h4 => {
      h4.addEventListener('click', () => {
        h4.parentElement.classList.toggle('closed');
      });
    });

    listJson(); // auto-load defaults
  </script>
</body>

</html>
